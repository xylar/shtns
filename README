Run "make docs" to generate documentation with doxygen.


/** \mainpage SHTns : Spherical Harmonic Transform for numerical simulations.
 * 
 * SHTns is a library for Spherical Harmonic Transform written in C, aimed at 
 * numerical simulation (fluid flows, mhd, ...) in spherical geometries.
 * 
 * Main features :
 * - both scalar and vector transforms
 * - backward and forward (synthesis and analysis) functions
 * - flexible truncation
 * - a highly efficient Gauss algorithm working with gauss nodes (based on Gauss-Legendre quadrature)
 * - an even faster algorithm using DCT for regular nodes (based on a generalized Fejer quadrature)
 * - can be used from fortran or c/c++ programs
 * - various conventions (normalization and Condon-Shortley phase)
 * - synthesis (inverse transform) at any coordinate (not constrained to a grid) useful for rendering purposes.
 *
 * Using DCT acceleration and other classical optimizations, it is intended to be <b>very fast</b>.
 * 
 * It uses the <a href="http://www.fftw.org/">FFTW</a> library for Fast Fourier Transforms, and is distributed under the GPL License.
 *
 * \see SHT.h for the definitions of variables, macros and functions.
 * \see The example programs (in \link SHT_example.f Fortran \endlink and \link SHT_example.f C \endlink) to get started.
 * \see The organisation of data used by SHTns is described in \ref spat.
 * \see The description of \ref opt.
 * \see SHTf77.c for the fortran interface.
 * 
 * \author SHTns is written by Nathanael Schaeffer (LGIT, CNRS)
*/



/** \page compil Compiling SHTns

type \c make to compile SHTns. It will produce the object file SHT.o

\section cflags Compilation flags and options

These symbol can be defined at compile time :
 - \c SHT_NO_DCT : disables DCT at compile time (smaller, simpler and maybe faster code for gauss SHT)
 - \c SHT_AXISYM : axysimmetric version of SHTns (m=0 only), which is supposed to be a little faster than setting MMAX=0 at runtime.
 - \c SHT_VERBOSE : sets the quantity of information to print during execution. Usefull for debugging.

*/



/** \page spat Spatial data layouts and grids used by SHTns 

The angular coordinates on a spherical shell are the co-latitude \f$ \theta \f$ and the longitude \f$ \phi \f$.

The spatial discretization is defined by a call to \ref shtns_init or to \ref shtns_precompute (afer \ref shtns_set_size).

A field \e A (or one of its component in case of a vector field) is discretized on an ordered grid, which consists of
 - NPHI equally spaced nodes in longitude, spanning the range of angle between 0 and \f$2\pi\f$/MRES,
 - NLAT gauss nodes or equally spaced nodes (depending on \ref shtns_type) in latitude, spanning angles from 0 to \f$ \pi \f$.

Identifying a grid point with its indices \c it and \c ip in latitudinal and longitudinal direction respectively (indices start at 0), one has :
 - \f$ \theta \f$ = \c acos(ct[it]) where \ref ct is initialized by the call to \ref shtns_init
 - \f$ \phi \f$ = \c ip * 2\f$\pi\f$/(NPHI*MRES)
 - How to access \f$ A(\theta,\phi) \f$ depends on the data layout, but it is always <b>a contiguous array of double precision floating point values</b> (64 bit)

Currently, three data layouts are supported. \ref phi_fast, \ref theta_fast, and \ref native.

\section phi_fast Contiguous longitudes

In this layout, increasing longitudes are stored next to each other for each latitude.
That is \f$ A(\theta,\phi) \f$ = \c A[it*NPHI + ip] in C or \c A(ip,it) in Fortran.
Use \ref SHT_PHI_CONTIGUOUS to instruct \ref shtns_init to use this spatial data layout :

\code shtns_init ( sht_gauss | SHT_PHI_CONTIGUOUS, ... ) \endcode will tell shtns to
precompute everything for a gauss nodes in latitude, and spatial data stored with phi varying
fastest.

\section theta_fast Contiguous latitudes

In this layout, increasing latitude are stored next to each other for each longitude.
That is \f$ A(\theta,\phi) \f$ = \c A[ip*NLAT + it] in C or \c A(it,ip) in Fortran.
Use \ref SHT_THETA_CONTIGUOUS to instruct \ref shtns_init to use this spatial data layout.

\section native Native layout

The native way of storing spatial field data (which will help you achieve the best performance with SHTns)
is the same as the \ref theta_fast layout, except that it requires you to allocate slightly more
memory for a field than the NLAT*NPHI double values.
Namely NLAT*(NPHI/2+1)*2 doubles are required (instead of NLAT*NPHI) to be able tu use the in-place FFT of FFTW.

In Fortran this means you will allocate data as if the phi direction had (NPHI/2+1)*2 points instead fo NPHI.
The aditional space, is located at the end of the useful data, and you don't need to worry about it.

To instruct \ref shtns_init that your spatial data has been set up using this layout, use \ref SHT_NATIVE_LAYOUT.

One must be careful when allocating spatial data, as the Fourier transform requires some aditional space.\n Precisely, the number
of required \c double is \ref NSPAT_ALLOC = NLAT*(NPHI/2+1)*2. The first NLAT*NPHI values are the spatial data.

In addition, spatial data must be allocated using the \c fftw_malloc function, for example using :
\code A = fftw_malloc( NSPAT_ALLOC * sizeof(double) );\endcode


*/


/** \page spec Spherical Harmonics storage and normalization

\section spec_data Spherical Harmonic coefficients layout

<b>The collection of Alm (spherical harmonics coefficient of degree \e l and order \e m) is stored in an array of \c complex \c double floating point values.</b>
The spherical harmonic truncation is defined by a call to \ref shtns_init or to \ref shtns_set_size which returns the size NLM of the array.

The field \em A is decomposed on the basis of spherical harmonics Ylm (degree \e l, order \e m) :
\f[ A(\theta,\phi) = \sum_{l,m} A_l^m Y_l^m(\theta,\phi)\f]
The series is truncated at degree LMAX and order MMAX*MRES, 
and only order that are multiple of MRES are described.

The NLM coefficients Alm are stored in a one-dimensional array, grouped by \e m.\n
The details of the storage may depend on the algorithm, and to access a particular coefficient, you should always use the following macros :
 - \ref LM(l,m) gives the index in the array for coefficient of degree \e l and order \e m.
 - \ref LiM(l,im) gives the index in the array for coefficient of degree \e l and order \e im*MRES.

Hence \c Alm[LM(l,m)] is the SH coefficient of degree \e l and order \e m.

\note There is no test on bounds, so that LM(l,m) with \e l or \e m that is not described, will give undefined result
(in particular for an \e m that is not a multiple of \c MRES)

To perform loops on all coefficients, use the macros \ref LM_LOOP and \ref LM_L_LOOP
in combination of the arrays \ref li, \ref el and \ref l2 which give the degree \e l and functions of it for any array index.

\section Allocation
Allocation for a SH description is simply done with :
\code Alm = malloc( NLM * sizeof(complex double) );\endcode

\section norm Normalization

The spherical harmonics used in SHTns are orthonormalized by default (like in the GSL) :

\f[ Y_l^m(\theta, \phi) = \sqrt{\frac{2l+1}{4\pi}} \sqrt{\frac{(l-m)!}{(l+m)!}} \, P_l^m(\cos \theta) \, \exp(im\phi) \f]

and the legendre associated function include the Condon-Shortley phase \f$ (-1)^m \f$ :

\f[ P_l^m (x) = (-1)^m\ (1-x^2)^{m/2}\ \frac{d^m}{dx^m}P_l(x) \f]

You can also use other normalizations and you can drop the Condon-Shortley phase 
by using \ref shtns_set_size.
For more details, see \ref sht_legendre.c.
Also, function \ref SH_to_point gives an explicit implementation of the inverse SH transform (synthesis).

A few useful examples, for orthonormal spherical harmonics :
 - a constant unit value on the sphere is represented by the coefficient \f$ c_0^0 = \sqrt{4\pi} \f$.
 - \f$ \cos \theta \f$ is represented by the coefficient \f$ c_1^0 = \sqrt{4\pi/3} \f$.
 - \f$ \sin \theta \, \cos \phi \f$ is represented by \f$ c_1^1 =  -\sqrt{2\pi/3} \f$ (with Condon-Shortley phase)

The functions \ref sh00_1(), \ref sh10_ct(), \ref sh11_st() will help to build simple
spectral fields, no matter what normalization you choose.

\subsection Troubleshooting
If you have problem in getting your spherical harmonic coefficient right, you may check the following :
 - Schmit semi-normalization ? try multiplying or dividing by \f$ \sqrt{2l+1} \f$
 - Condon-Shortley phase ? try multiplying by \f$ (-1)^m \f$
 - Real or Complex ? try multiplying or dividing the m>0 coefficients by \f$ \sqrt{2} \f$
 - Does the array include l=0 ?

*/

/** \page opt Optimizations implemented in SHTns

SHTns is an implementation of the Spherical Harmonic Transform which aims at beiing accurate and fast,
with direct numerical simulations in mind. As such, the following optimizations are implemented :

\section opt_fft Use the Fast-Fourier Transform

Any serious SHT should use the FFT, as it improves accuracy and speed.
SHTns uses the FFTW library for the fast Fourier transform, a portable, 
flexible and blazingly fast FFT implementation.

\section opt_mirror Take advantage of mirror symmetry

This is also a classical optimization. Due to the defined symmetry of spherical harmonics with respect
to a reflexion about the equator, one can reduce by a factor 2 the operation count of both direct and reverse
transforms.

\section opt_polar Polar optimization

A less common, but still classic optimization : high m's spherical harmonics have their magnitude descrease exponentially
when aproaching the poles. SHTns use a threshold below which the SH is take to be zero.
You can choose this threshold, with the \c eps parameter of the \ref shtns_init function, trading some accuracy for more speed.
Around 5% to 15% speed increase are typical values for a SHT with a large MMAX.

\section opt_cache Cache optimizations

Cache optimizations have been carried out throughout the code.
This means ordering coefficients and stripping out systematic zeros.

\section opt_dct Discrete Cosine Transform optimization

This is a non-trivial optimization mostly efficient on small m's,
which can significantly decrease the operation count.

It can be noticed that Spherical Harmonics are polynomials 
of order \f$ l \f$ in \f$ \cos \theta \f$ (multiplied by \f$ \sin \theta \f$ for odd m's).
Thus, going to DCT space and summing there can help to further reduce the number of operations.

Using a DCT requires a regular grid instead of the usual Gauss grid, and this
means doubling the number of grid points to keep an equally accurate quadrature (Tchebychev quadrature), reducing
the performance gain from the DCT to zero, when not performing worse.

However, SHTns uses a quadrature inspired by the Fejer quadrature (or Clenshaw-Curtis), which allows exact result
using only one more grid-point than the classical Gauss-Legendre quadrature.
This allows SHTns to efficiently use the DCT optimization, but also to use regular grids with
almost half the grid points as usual.

The theoretical result is that for a function band-limited by L, L+2 equispaced grid-points allow us
to fully recover the spectral content.
There is still a drawback for non-linear terms : for a non-linear product of two functions band-limited to L,
we would require L*2+2 grid points, whereas the Gauss-Legendre quadrature would only require (L+1)*3/2 grid-points if we
are interested in only the first L modes of the product.

There is a slight loss of accuracy due to round-off errors (as an example, relative errors 
with DCT are around \c 1.e-11 instead of \c 1.e-12 without for lmax around 500).
If you can live with it, the DCT-based algorithm performs much faster on small m's :
twice as fast for axisymmetric transforms, and between 1.5 and 1.2 times faster on non-axisymmetric ones.
For large m's however the spatial-domain polar optimization takes the lead.

Note also that the DCT algorithm, while beeing usually faster, requires significantly larger init time. It
is then suitable for performing many transforms (as in a direct numerical simulations).

<b>Warning : this is still at the research stage (beta), you should use with caution and test before production use.</b>

\section opt_runtime Runtime tuning of algorithm

The default mode used by SHTns is to measure performance of the different algorithms, and choose
the one that performs best (it will also check that the accuracy is good enough).
However, there are situation where either the Gauss-Legendre algorithm or a regular grid is required, and you
can choose to do so using the adequate \ref shtns_type when calling \ref shtns_init.



*/

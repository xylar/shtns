Run "make docs" to generate documentation with doxygen.
Then browse the html documentation starting with doc/html/index.html

/** \mainpage SHTns : Spherical Harmonic Transform for numerical simulations.
 * 
 * SHTns is a library for Spherical Harmonic Transform written in C, aimed at 
 * numerical simulation (fluid flows, mhd, ...) in spherical geometries.
 * 
 * Main features :
 * - both scalar and vector transforms
 * - backward and forward (synthesis and analysis) functions
 * - flexible truncation
 * - spatial data can be stored in latitude-major or longitude-major order arrays.
 * - various conventions (normalization and Condon-Shortley phase)
 * - can be used from fortran or c/c++ programs
 * - a highly efficient Gauss algorithm working with gauss nodes (based on Gauss-Legendre quadrature)
 * - an even faster algorithm using DCT for regular nodes (based on a generalized Fejer quadrature)
 * - synthesis (inverse transform) at any coordinate (not constrained to a grid) useful for rendering purposes.
 *
 * Using DCT acceleration and other classical optimizations, it is intended to be <b>very fast</b>.
 * 
 * It uses the <a href="http://www.fftw.org/">FFTW</a> library for Fast Fourier Transforms, and is distributed under the GPL License.
 *
 * \see shtns.h for the definitions of variables, macros and functions.
 * \see The example programs (in \link SHT_example.f Fortran \endlink and \link SHT_example.c C \endlink) to get started.
 * \see The organisation of data used by SHTns is described in \ref spat.
 * \see The description of \ref opt.
 * 
 * \author SHTns is written by Nathanael Schaeffer (LGIT, CNRS)
*/



/** \page compil Compiling and installing SHTns

You should edit the Makefile to adapt it to your architecture and compiler. In particular, using gcc or icc will not lead to the same performance, and you
should test on your system what gives the best result.

\li type \code make \endcode to compile SHTns. it will produce the library \c libshtns.a

\li type \code make PREFIX=/usr/local install \endcode to install the library in your system (set PREFIX to the desired location, default is $HOME).

\li type \code make docs \endcode to generate this documentation, placed in the doc/html/ subdirectory.

\section cflags Compilation flags and options

A few compilation options can be set in \ref sht_config.h

*/



/** \page spat Spatial data layouts and grids used by SHTns 

The angular coordinates on a spherical shell are the co-latitude \f$ \theta \f$ and the longitude \f$ \phi \f$.

The spatial discretization is defined by a call to \ref shtns_init or to \ref shtns_precompute (afer \ref shtns_set_size).

A field \e A (or one of its component in case of a vector field) is discretized on an ordered grid, which consists of
 - NPHI equally spaced nodes in longitude, spanning the range of angle between 0 and \f$2\pi\f$/MRES,
 - NLAT gauss nodes or equally spaced nodes (depending on \ref shtns_type) in latitude, spanning angles from 0 to \f$ \pi \f$.

Identifying a grid point with its indices \c it and \c ip in latitudinal and longitudinal direction respectively (indices start at 0), one has :
 - \f$ \theta \f$ = \c acos(ct[it]) where \ref ct is initialized by the call to \ref shtns_init
 - \f$ \phi \f$ = \c ip * 2\f$\pi\f$/(NPHI*MRES)
 - How to access \f$ A(\theta,\phi) \f$ depends on the data layout, but it is always <b>a contiguous array of double precision floating point values</b> (64 bit)

Currently, three data layouts are supported. \ref phi_fast, \ref theta_fast, and \ref native.

\section phi_fast Contiguous longitudes

In this layout, increasing longitudes are stored next to each other for each latitude.
That is \f$ A(\theta,\phi) \f$ = \c A[it*NPHI + ip] in C or \c A(ip,it) in Fortran.
Use \ref SHT_PHI_CONTIGUOUS to instruct \ref shtns_init to use this spatial data layout :

\code shtns_init ( sht_gauss | SHT_PHI_CONTIGUOUS, ... ) \endcode will tell shtns to
precompute everything for a gauss nodes in latitude, and spatial data stored with phi varying
fastest.

\section theta_fast Contiguous latitudes

In this layout, increasing latitude are stored next to each other for each longitude.
That is \f$ A(\theta,\phi) \f$ = \c A[ip*NLAT + it] in C or \c A(it,ip) in Fortran.
Use \ref SHT_THETA_CONTIGUOUS to instruct \ref shtns_init to use this spatial data layout.

\section native Native layout

The native way of storing spatial field data (which will help you achieve the best performance with SHTns)
is the same as the \ref theta_fast layout, except that it requires you to allocate slightly more
memory for a field than the NLAT*NPHI double values.
Namely NLAT*(NPHI/2+1)*2 doubles are required (instead of NLAT*NPHI) to be able tu use the in-place FFT of FFTW.

In Fortran this means you will allocate data as if the phi direction had (NPHI/2+1)*2 points instead fo NPHI.
The aditional space, is located at the end of the useful data, and you don't need to worry about it.

To instruct \ref shtns_init that your spatial data has been set up using this layout, use \ref SHT_NATIVE_LAYOUT.

One must be careful when allocating spatial data, as the Fourier transform requires some aditional space.\n Precisely, the number
of required \c double is \ref NSPAT_ALLOC = NLAT*(NPHI/2+1)*2. The first NLAT*NPHI values are the spatial data.

In addition, spatial data must be allocated using the \c fftw_malloc function, for example using :
\code A = fftw_malloc( NSPAT_ALLOC * sizeof(double) );\endcode


*/


/** \page spec Spherical Harmonics storage and normalization

\section spec_data Spherical Harmonic coefficients layout

<b>The collection of Alm (spherical harmonics coefficient of degree \e l and order \e m) is stored in an array of \c complex \c double floating point values.</b>
The spherical harmonic truncation is defined by a call to \ref shtns_init or to \ref shtns_set_size which returns the size NLM of the array.

The field \em A is decomposed on the basis of spherical harmonics Ylm (degree \e l, order \e m) :
\f[ A(\theta,\phi) = \sum_{l,m} A_l^m Y_l^m(\theta,\phi)\f]
The series is truncated at degree LMAX and order MMAX*MRES, 
and only order that are multiple of MRES are described.

The NLM coefficients Alm are stored in a one-dimensional array, grouped by \e m.\n
The details of the storage may depend on the algorithm, and to access a particular coefficient, you should always use the following macros :
 - \ref LM(l,m) gives the index in the array for coefficient of degree \e l and order \e m.
 - \ref LiM(l,im) gives the index in the array for coefficient of degree \e l and order \e im*MRES.

Hence \c Alm[LM(l,m)] is the SH coefficient of degree \e l and order \e m.

\note There is no test on bounds, so that LM(l,m) with \e l or \e m that is not described, will give undefined result
(in particular for an \e m that is not a multiple of \c MRES)

To perform loops on all coefficients, use the macros \ref LM_LOOP and \ref LM_L_LOOP
in combination of the arrays \ref li, \ref el and \ref l2 which give the degree \e l and functions of it for any array index.

\section Allocation
Allocation for a SH description is simply done with :
\code Alm = malloc( NLM * sizeof(complex double) );\endcode

\section norm Normalization

Several normalizations for the spherical harmonics exist (<a href="http://en.wikipedia.org/wiki/Spherical_harmonics#Conventions">details on wikipedia</a>).
SHTns lets you choose one of the following :
<ul>
<li><b>Orthonormalized</b> is the default (also used in the <a href="http://www.gnu.org/software/gsl/">GSL</a>)

\f[ Y_l^m(\theta, \phi) = \sqrt{\frac{2l+1}{4\pi}} \sqrt{\frac{(l-m)!}{(l+m)!}} \, P_l^m(\cos \theta) \, \exp(im\phi) \f]

</li><li><b>Four-pi normalized</b>

\f[ Y_l^m(\theta, \phi) = \sqrt{2l+1} \sqrt{\frac{(l-m)!}{(l+m)!}} \, P_l^m(\cos \theta) \, \exp(im\phi) \f]

</li><li><b>Schmidt semi-normalized</b>

\f[ Y_l^m(\theta, \phi) = \sqrt{\frac{(l-m)!}{(l+m)!}} \, P_l^m(\cos \theta) \, \exp(im\phi) \f]

</li></ul>

\ref shtns_init uses the default (defined by \ref SHT_DEFAULT_NORM) but you can choose another normalization
by calling \ref shtns_set_size instead.

The legendre associated functions are defined by :

\f[ P_l^m (x) = (-1)^m\ (1-x^2)^{m/2}\ \frac{d^m}{dx^m}P_l(x) \f]

which includes the Condon-Shortley phase \f$ (-1)^m \f$ by default.
Use \ref shtns_set_size with \ref SHT_NO_CS_PHASE to disable the Condon-Shortley phase.
For example, to initialize a Schmidt semi-normalized transform of maximum degree 16 without Condon-Shortrley phase, use
\code shtns_set_size(16, 16, 1, sht_schmidt | SHT_NO_CS_PHASE); \endcode

Also, function \ref SH_to_point gives an explicit implementation of the inverse SH transform (synthesis).

A few useful examples, for orthonormal spherical harmonics :
 - a constant unit value on the sphere is represented by the coefficient \f$ c_0^0 = \sqrt{4\pi} \f$.
 - \f$ \cos \theta \f$ is represented by the coefficient \f$ c_1^0 = \sqrt{4\pi/3} \f$.
 - \f$ \sin \theta \, \cos \phi \f$ is represented by \f$ c_1^1 =  -\sqrt{2\pi/3} \f$ (with Condon-Shortley phase)

The functions \ref sh00_1(), \ref sh10_ct(), \ref sh11_st() will help to build simple
spectral fields, no matter what normalization you choose.

\subsection Troubleshooting
If you have problem in getting your spherical harmonic coefficient right, you may check the following :
 - Schmit semi-normalization ? try multiplying or dividing by \f$ \sqrt{2l+1} \f$
 - Condon-Shortley phase ? try multiplying by \f$ (-1)^m \f$
 - Real or Complex ? try multiplying or dividing the m>0 coefficients by \f$ \sqrt{2} \f$
 - Does the array include l=0 ?

*/



/** \page opt Optimizations implemented in SHTns

SHTns is an implementation of the Spherical Harmonic Transform which aims at being accurate and fast,
with direct numerical simulations in mind. As such, the following optimizations are implemented :

\section opt_fft Use the Fast-Fourier Transform

Any serious SHT should use the FFT, as it improves accuracy and speed.
SHTns uses the <a href="http://www.fftw.org/">FFTW library</a> for the fast Fourier transform, a portable, 
flexible and blazingly fast FFT implementation.

\section opt_mirror Take advantage of mirror symmetry

This is also a classical optimization. Due to the defined symmetry of spherical harmonics with respect
to a reflexion about the equator, one can reduce by a factor 2 the operation count of both direct and reverse
transforms.

\section opt_polar Polar optimization

A less common, but still classic optimization : high m's spherical harmonics have their magnitude descrease exponentially
when aproaching the poles. SHTns use a threshold below which the SH is taken to be zero.
The default value for this threshold is defined by \ref SHT_DEFAULT_POLAR_OPT,
but you can also choose it with the \c eps parameter of the \ref shtns_precompute function,
trading some accuracy for more speed.
Around 5% to 15% speed increase are typical values for a SHT with a large MMAX.

\section opt_cache Cache optimizations

Cache optimizations have been carried out throughout the code.
This means ordering coefficients and stripping out systematic zeros.

\section opt_dct Discrete Cosine Transform optimization

This is a non-trivial optimization mostly efficient on small m's,
which can significantly decrease the operation count.

It can be noticed that Spherical Harmonics are polynomials 
of order \f$ l \f$ in \f$ \cos \theta \f$ (multiplied by \f$ \sin \theta \f$ for odd m's).
Thus, going to DCT space and summing there can help to further reduce the number of operations.

Using a DCT requires a regular grid instead of the usual Gauss grid, and this
means doubling the number of grid points to keep an equally accurate quadrature (Tchebychev quadrature), reducing
the performance gain from the DCT to zero, when not performing worse.

However, SHTns uses a quadrature inspired by the Fejer quadrature (or Clenshaw-Curtis), which allows exact result
using only one more grid-point than the classical Gauss-Legendre quadrature.
This allows SHTns to efficiently use the DCT optimization, but also to use regular grids with
almost half the grid points as usual.

The theoretical result is that for a function band-limited by L, L+2 equispaced grid-points allow us
to fully recover the spectral content.
There is still a drawback for non-linear terms : for a non-linear product of two functions band-limited to L,
we would require L*2+2 grid points, whereas the Gauss-Legendre quadrature would only require (L+1)*3/2 grid-points if we
are interested in only the first L modes of the product.

There is a slight loss of accuracy due to round-off errors (as an example, relative errors 
with DCT are around \c 1.e-11 instead of \c 1.e-12 without for lmax around 500).
If you can live with it, the DCT-based algorithm performs much faster on small m's :
twice as fast for axisymmetric transforms, and between 1.5 and 1.2 times faster on non-axisymmetric ones.
For large m's however the spatial-domain polar optimization takes the lead.

Note also that the DCT algorithm, while beeing usually faster, requires significantly larger init time. It
is then suitable for performing many transforms (as in a direct numerical simulations).

<b>Warning : this is still at the research stage (beta), you should use with caution and test before production use.</b>

\section opt_runtime Runtime tuning of algorithm

The default mode used by SHTns is to measure performance of the different algorithms, and choose
the one that performs best (it will also check that the accuracy is good enough).
However, there are situation where either the Gauss-Legendre algorithm or a regular grid is required, and you
can choose to do so using the adequate \ref shtns_type when calling \ref shtns_init or \ref shtns_precompute.

*/

/** \page usage Using SHTns in a C program

First of all you need to initialize SHTns. There are two ways to do this :
\li calling \ref shtns_init function,
\li or calling \ref shtns_set_size followed by \ref shtns_precompute. This way lets you choose normalization and optimization.

Note that you can call initialization function(s) only once.
Then you must allocate some memory, and finaly you can perform some spherical harmonic transforms.

\see Look at shtns.h for the function definitions and documentation.
\see See the \link SHT_example.c C example \endlink for a simple usage of SHTns in a C program.

*/


/** \page f77 Using SHTns with Fortran 77

SHTns provides an interface to Fortran language (compatible with gfortran).

First of all you need to initialize SHTns. There are two ways to do this :
\li calling one of the shtns_init_* subroutines,
\li or calling shtns_set_size followed by shtns_precompute. This way lets you choose normalization and optimization.

Note that you can call initialization function(s) only once.
Then you must allocate some memory, and finaly you can perform some spherical harmonic transforms.

\see See The full reference of the \ref fortapi
\see See the \link SHT_example.f Fortran example \endlink for a simple usage of SHTns from Fortran language.

\example SHT_example.f
  \brief A Fortran example program that performs backward and forward Spherical Harmonic Transforms using SHTns.
  Compile using : \code make SHT_fort_ex \endcode
  \see fortapi

*/

/** \page python Using SHTns with Python

SHTns provides a Python interface, for interactive use of the spherical harmonic transform.
It uses swig to generate the Python interface.

\li Compile using \code make python \endcode

\li Use within a python script or shell in the same directory \code from shtns import * \endcode

The functions available are the same as the \link usage C interface \endlink, plus some memory allocation functions...

*/

